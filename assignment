Q1> Explore the DVM instructions and prepare a summary of the same atleast for 5 instructions in a detailed format
The first column in the format table lists the bitwise layout of the format. It consists of one or more space-separated "words" each of which describes a 16-bit code unit. Each character in a word represents four bits, read from high bits to low, with vertical bars ("|") interspersed to aid in reading. Uppercase letters in sequence from "A" are used to indicate fields within the format (which then get defined further by the syntax column). The term "op" is used to indicate the position of an eight-bit opcode within the format. A slashed zero ("Ø") is used to indicate that all bits must be zero in the indicated position.
For the most part, lettering proceeds from earlier code units to later code units, and low-order to high-order within a code unit. However, there are a few exceptions to this general rule, which are done in order to make the naming of similar-meaning parts be the same across different instruction formats. These cases are noted explicitly in the format descriptions.
For example, the format "B|A|op CCCC" indicates that the format consists of two 16-bit code units. The first word consists of the opcode in the low eight bits and a pair of four-bit values in the high eight bits; and the second word consists of a single 16-bit value.
Syntax
The third column of the format table indicates the human-oriented syntax for instructions which use the indicated format. Each instruction starts with the named opcode and is optionally followed by one or more arguments, themselves separated with commas.Wherever an argument refers to a field from the first column, the letter for that field is indicated in the syntax, repeated once for each four bits of the field. For example, an eight-bit field labeled "BB" in the first column would also be labeled "BB" in the syntax column.Arguments which name a register have the form "vX". The prefix "v" was chosen instead of the more common "r" exactly to avoid conflicting with (non-virtual) architectures on which a Dalvik virtual machine might be implemented which themselves use the prefix "r" for their registers. (That is, this decision makes it possible to talk about both virtual and real registers together without the need for circumlocution.)Arguments which indicate a literal value have the form "#+X". Some formats indicate literals that only have non-zero bits in their high-order bits; for these, the zeroes are represented explicitly in the syntax, even though they do not appear in the bitwise representation.Arguments which indicate a relative instruction address offset have the form "+X".Arguments which indicate a literal constant pool index have the form "kind@X", where "kind" indicates which constant pool is being referred to. Each opcode that uses such a format explicitly allows only one kind of constant; see the opcode reference to figure out the correspondence. The four kinds of constant pool are "string" (string pool index), "type" (type pool index), "field" (field pool index), and "meth" (method pool index).Similar to the representation of constant pool indices, there are also suggested (optional) forms that indicate prelinked offsets or indices. There are two types of suggested prelinked value: vtable offsets (indicated as "vtaboff") and field offsets (indicated as "fieldoff").
In the cases where a format value isn't explictly part of the syntax but instead picks a variant, each variant is listed with the prefix "[X=N]" (e.g., "[A=2]") to indicate the correspondence.
Format	  ID	Syntax	Notable Opcodes Covered
N/A	  00x	N/A	pseudo-format used for unused opcodes; suggested for use as the nominal format for a breakpoint opcode
ØØ|op	  10x	op	 
B|A|op	  12x	op vA,  vB	 
	  11n	op vA,  #+B	 
AA|op	  11x	op vAA	 
	  10t	op +AA	goto
ØØ|opAAAA	20t	op +AAAA	goto/16


Q2> Differentiate between mobile and cloud computing
       Cloud computing, one of the new buzz words of 2008, allows you to store your files and folders in a “cloud” area on the Internet, allowing you access to all of your files and folders wherever you are in the world – but you do need a physical device with Internet access to access it.
Mobile computing is taking a physical device with you. This could be a laptop or a mobile phone or some device which enables you to telework – working wherever you go because of the small size of the device you’re using.
Either way, there will be some drawbacks. I’m not going to focus on the positives too much, simply because being able to do work shouldn’t have to be a positive thing, rather something we should just be able to do without any concern.
Focusing for the time being on mobile computing – let’s face it, even for non-students it generally means lugging a laptop around with you. You have to open it up, turn it on, plug it in to the mains, get the wireless settings sorted – by the time you’ve done all that faffing around you have to get something else done. For the lucky ones, you can use a Blackberry or a handheld device to work with. Even then the buttons are tiny, and months of living off nothing but sausages, crisps (chips), chocolate and beer, you’ve gained so much wait you mash the keypad with your finger because they’ve become huge and fat.
Cloud computing isn’t that much better. Sure, you can have all your files synchronised between devices so wherever you go, you’ll always have access to your files, but the technology doesn’t fully exist yet. It’s getting there, but it’s slow and temperamental, difficult to use and often the average user (even me, an advanced user) gets confused as to where the files are actually stored and/or where else they are stored. Even though you don’t need to carry round a laptop with you, you still need some physical device to access your service which almost defeats the point anyway. Having everything in your very own secure cloud so you can access anything anywhere is put back by the fact you have to find a computer to use anyway.

Q3> Give an example of an application simulating an environment of  context aware computing and justify.
        Context-Awareness (CA) is a promising paradigm to personalize applications. Traditionally, non-CA applications only use explicit user-inputs to provide output. CA applications use additional implicit (sensed) context inputs collected from the user’s environment, to tailor the output to the user’s need . Context (e.g. location, speed) is sensed from the user’s physical environment or derived from the user’s computing environment. In CA applications, context sources represent software entities that produce context information relevant for the CA application 
  The design and development of CA applications does not only concern traditional application logic, but also includes logic that deals with gathering and processing of context information coming from context sources. Therefore, application developers also face the challenges posed by the use of context sources. Currently, context-aware technologies are still evolving and are not yet widely deployed. Therefore, to develop context-aware applications, a significant extra amount of development effort may go into the implementation of context sources. The general structure of such a context source is that it acquires raw data from a data source (e.g. sensor), possibly performs some processing and then transforms it into a data structure suitable for the context-aware application. 
Implementing these data transformations is quite cumbersome and time consuming. Furthermore, due to the device-specific nature of context sources, reusability of context sources and their transformations for other applications is limited. For example, to implement a context source of a Bluetooth GPS, the developer has to build a context source that can communicate with Bluetooth and the NMEA data format and then transform this to the data format that can be used by the CA application. Ideally, CA application developers want to abstract from the internals of context sources and treat them as a black box. Their effort should go in the development of the CA application logic which includes interfacing with desired context sources. We recognize that for operational CA services, physical context sources are mandatory. However, we envision that in the future third parties will develop context sources and therefore creating new context sources seems redundant, takes scarce development time and distracts from the real challenge of developing a CA application.
 Furthermore, testing and demonstrating CA applications in a controllable and reproducible way with physical context sources may prove extremely difficult. By nature, context information is highly dynamic (i.e. dynamic in value and quality) . Therefore, retrieving the same context in similar situations is hard. For example, when using a GPS, standing in the same spot can result in different context values over time due to changing accuracy. Also practically, it is hard to use life context information during tests or demonstrations. For example, GPS does not work inside buildings, which means that tests and demonstrations have to take place outside. In this paper, we propose a context simulation framework (SimuContext). Simulation in general provides many benefits for software development like, cost reduction, improve reliability and shorten development time . Our framework facilitates application developers in testing and demonstrating CA applications by only specifying the behavior of context sources and using simulated context sources as inputs in their CA application. As a result, CA application developers can concentrate on the logic of their application and do not have to worry about the complexities of dealing with physical context sources. The SimuContext framework has the potential to offer CA application developers the following: 
• Rapid testing and demonstration of CA applications, in a controllable and reproducible manner, through configuration of existing SimuContext capabilities or by extending parts of the framework. 
• Creation of a more comprehensive and realistic validation environment by deploying a multitude of SimuContext sources with specified properties. 
• Easy replacement of SimuContext sources by physical context sources due to a realistic context model and generic SimuContext interfaces. 
• Test specific characteristics of context sources for CA applications like subscribe/notify mechanism, connection loss, reasoning, quality changes etc. 
  Bylund  distinguishes two types of context simulation tools: (i) a simulation suite that simulates context values and (ii) a semi-realistic simulation environment. We have chosen the first approach to offer a generic simulation facility which can provide a configurable set of context source types and instances, tailored to a specific CA application scenario. Summarizing, the SimuContext framework substitutes the implicit context inputs of CA applications with context inputs from SimuContext sources. 


